# pwa-vault

That project is about a PWA based password manager, inspired by [gauravchl/secure-wallet](https://github.com/gauravchl/secure-wallet).

Currently, no dev was initiated, it’s only some reflexions about a possible implementation.

## Crypto

- Data (passwords) are encrypted via AES256-GCM with a key named `k1`,
- AES key `k1` is generated by [Crypto.getRandomValues](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues),
- User master password is used in argon2id, with a salt named `S`, to generate a key named `k2`,
- Argon2 salt `S` is generated by [Crypto.getRandomValues](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues),
- AES key `k1` is encrypted with key `k2`.

Key `k1` is stored encrypted in localStorage ; `k2` is never stored on drive, it only exists in memory.

Argon2 salt is stored unencrypted in localStorage (it’s only here to prevent pre-computed attacks, a.k.a rainbow tables).

### Use case : « log in » and access encrypted data

1. User types its master password,
2. we use argon2id with the master password and the salt S to generate key `k2`,
3. We decrypt with AES256 encrypted key `k1` with key `k2`,
4. We can then decrypt data with AES256 and decrypted key `k1`.

### Use case : creation

1. A salt `S` is generated by [Crypto.getRandomValues](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues),
2. User master password is used in argon2id, with the salt `S` to generate a key named `k2`,
3. AES key `k1` is generated by [Crypto.getRandomValues](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues),
4. We encrypt key `k1` with key `k2`,
5. We store salt `S` & encrypted key `k1` in localStorage.

## Data in localStorage

- encrypted key `k1`
- encrypted data
- argon2 parameters : salt `S` (in clear text), number of iterations, parallelism, used memory, hash length
- version number, incremented after each change
- username, used to store data on server
- secret key generated from server after first upload (needed to upload data)

## Data on server

After each change, data in localStorage is uploaded to a server.
Data is never overwritten but wrote « by version » to avoid any data loss.

Note that conflict resolution isn’t handled for now (but since data is never overwritten, we could « manually » restore a previous version).

When app is loaded, last version of data is fetched from the server and will replace localStorage if more recent.

A secret is generated by the server on the first upload, needed for future upload (to avoid an attacker overwrites user’s data)

## Technological Stack

- [Web Cryptography API](https://www.w3.org/TR/WebCryptoAPI/) (random, AES)
- argon2id
- react (create-react-app)
- material-design
- server in node

## Resources

- https://cryptobook.nakov.com/
- https://crypto.stackexchange.com/
- https://diafygi.github.io/webcrypto-examples/
- https://1password.com/files/1Password-White-Paper.pdf
- https://www.ise.io/casestudies/password-manager-hacking/
